% RRT-connect算法
% clc
% clear
close all
tic
global len nodeNum time
%% 地图构建
map_size = [50, 30];
startPos = [2,2];
goalPos = [49,26];
map = fun_defMap; % 定义地图
stepLength = 2;            % 步长
rou = 5;                   % 圆形区域半径
Final = false;
%% 算法
% 定义树节点1
treeNodes1 = struct;
treeNodes1.node = startPos;
treeNodes1.parentNode = startPos;
treeNodes1.dist = 0;
% 定义树节点2
treeNodes2 = struct;
treeNodes2.node = goalPos;
treeNodes2.parentNode = goalPos;
treeNodes2.dist = 0;

nodeNum1 = 1;
nodeNum2 = 1;
while Final == false
%     [x_nearest,x_new,collision_flag] = getNewNode(map,map_size,treeNodes1,stepLength);
    % 在地图空间随机采样撒点
    x_rand(1) = map_size(1)*rand;
    x_rand(2) = map_size(2)*rand;
    
    % 依次遍历每一个树节点到采样点的距离，取最小值对应的树节点
    dist = [];
    for i = 1:size(treeNodes1,2)
        dist(i) = norm(treeNodes1(i).node - x_rand);
    end
    [~,idx_min] = min(dist);
    x_nearest = treeNodes1(idx_min).node ;
    
    % 计算随机点方向x2的扩展步长
    direction = x_rand - x_nearest;
    unitDirection = direction / norm(direction);
    x2 = stepLength * unitDirection;
    
    % 生成新的节点
    x_new = x_nearest + x2;
    
    % 碰撞检测
    collision_flag = collision_check(map,x_nearest,x_new);

    % 判断父节点与子节点的连线是否跨过障碍物
    if collision_flag == 0
        continue;
    else
        % 将x_new追加到树1上
        nodeNum1 = nodeNum1 + 1;
        treeNodes1(nodeNum1).node = x_new;
        treeNodes1(nodeNum1).parentNode = x_nearest;
        treeNodes1(nodeNum1).dist = treeNodes1(idx_min).dist + stepLength;

        % 依次遍历除了x_new之外的每一个treeNodes1树节点到x_new的距离，选取位于圆形区域内的树节点
        idx_nearest = [];
        for i = 1:size(treeNodes1,2)-1
            collision_flag = collision_check(map,treeNodes1(i).node,x_new);
            dist = norm(treeNodes1(i).node - x_new);
            if dist < rou && collision_flag == 1
                idx_nearest(end+1,:) = i;
            end
        end

        % 判断圆形区域内哪一个节点到源节点的距离更近
        if ~isempty(idx_nearest)
            dist = [];
            for i = 1:length(idx_nearest)
                idx = idx_nearest(i);
                dist(i) = norm(treeNodes1(idx).node - x_new) + treeNodes1(idx_nearest(i)).dist;
            end
            [dist_min,idx_min] = min(dist);
            treeNodes1(nodeNum1).parentNode = treeNodes1(idx_nearest(idx_min)).node;
            treeNodes1(nodeNum1).dist = dist_min;
            
            % 更新圆内的其他最近邻节点，判断经过x_new到达此邻接点路径是否更优
            for i = 1:length(idx_nearest)
                idx = idx_nearest(i);
                collision_flag = collision_check(map,treeNodes1(idx).node,x_new);
                dist_temp = norm(treeNodes1(idx).node - x_new);
                if collision_flag == 1 && dist_min + dist_temp < treeNodes1(idx).dist
                    treeNodes1(idx).parentNode = x_new;
                    treeNodes1(idx).dist = dist_min + dist_temp;
                end
            end
        end

        % 计算树2到x_new最近的节点
        dist = [];
        for i = 1:nodeNum2
            dist(i) =  norm(treeNodes2(i).node - x_new);
        end
        [dist_min,idx_min] = min(dist);
        x_nearest_temp = treeNodes2(idx_min).node;
        % 判断树1的x_new与树2的x_nearest_temp连线是否满足碰撞检测
        collision_flag = collision_check(map,x_nearest_temp,x_new);  
        
        if dist_min < stepLength * 2 && collision_flag == 1
            idx1_break = nodeNum1;
            idx2_break = idx_min;
            Final = true;
%             break
        else
            % treeNodes2(idx_min)节点朝x_new方向生长
            direction = x_new - x_nearest_temp;
            unitDirection = direction / norm(direction);
            x_new_temp = stepLength * unitDirection + x_nearest_temp;
            while true
                % 判断新生成的节点是否满足碰撞检测
                collision_flag = collision_check(map,x_nearest_temp,x_new_temp);
                if collision_flag == 1
                    nodeNum2 = nodeNum2 + 1;
                    treeNodes2(nodeNum2).node = x_new_temp;
                    treeNodes2(nodeNum2).parentNode = x_nearest_temp;
                    treeNodes2(nodeNum2).dist = treeNodes2(idx_min).dist + stepLength;

                    % 依次遍历除了x_new_temp之外的每一个treeNodes2树节点到x_new的距离，选取位于圆形区域内的树节点
                    idx_nearest = [];
                    for i = 1:size(treeNodes2,2)-1
                        collision_flag = collision_check(map,treeNodes2(i).node,x_new_temp);
                        dist = norm(treeNodes2(i).node - x_new_temp);
                        if dist < rou && collision_flag == 1
                            idx_nearest(end+1,:) = i;
                        end
                    end
            
                    % 判断圆形区域内哪一个节点到源节点的距离更近
                    if ~isempty(idx_nearest)
                        dist = [];
                        for i = 1:length(idx_nearest)
                            idx = idx_nearest(i);
                            dist(i) = norm(treeNodes2(idx).node - x_new_temp) + treeNodes2(idx_nearest(i)).dist;
                        end
                        [dist_min,idx_min] = min(dist);
                        treeNodes2(nodeNum2).parentNode = treeNodes2(idx_nearest(idx_min)).node;
                        treeNodes2(nodeNum2).dist = dist_min;
                        
                        % 更新圆内的其他最近邻节点，判断经过x_new_temp到达此邻接点路径是否更优
                        for i = 1:length(idx_nearest)
                            idx = idx_nearest(i);
                            collision_flag = collision_check(map,treeNodes2(idx).node,x_new_temp);
                            dist_temp = norm(treeNodes2(idx).node - x_new_temp);
                            if collision_flag == 1 && dist_min + dist_temp < treeNodes2(idx).dist
                                treeNodes2(idx).parentNode = x_new_temp;
                                treeNodes2(idx).dist = dist_min + dist_temp;
                            end
                        end
                    end

                    % 计算树1到x_new_temp最近的节点
                    dist = [];
                    for i = 1:nodeNum1
                        dist(i) =  norm(treeNodes1(i).node - x_new_temp);
                    end
                    [dist_min,idx_min_tr1] = min(dist);
                    x_nearest_temp = treeNodes1(idx_min_tr1).node;
                    % 判断树2的x_new_temp与树1的x_nearest_temp连线是否满足碰撞检测
                    collision_flag = collision_check(map,x_nearest_temp,x_new_temp);  
                    
                    if dist_min < stepLength * 2 && collision_flag == 1
                        idx1_break = idx_min_tr1;
                        idx2_break = nodeNum2;
                        Final = true;
                        break;
                    end
                    % 持续搜索
%                     x_nearest_temp = x_new_temp;
%                     x_new_temp = x_nearest_temp + stepLength * unitDirection;
                    % 不持续搜索
                    break;
                else
                    % 交换树节点
                    temp = treeNodes1;
                    treeNodes1 = treeNodes2;
                    treeNodes2 = temp;
                    
                    % 交换树结点数目
                    temp = nodeNum1;
                    nodeNum1 = nodeNum2;
                    nodeNum2 = temp;
                    break;
                end
            end
        end
    end
end

%% 最优路径
path_opt = [];
idx = idx1_break;
for i = 1:2
    if i == 1
        treeNodes = treeNodes1;
    else
        path_opt = path_opt(end:-1:1,:); % 反转
        treeNodes = treeNodes2;
        idx = idx2_break;
    end
    while true
        path_opt(end+1,:) = treeNodes(idx).node;
        x_nearest = treeNodes(idx).parentNode;
        if isequal(x_nearest,startPos)
            path_opt(end+1,:) = startPos;
            break;
        elseif isequal(x_nearest,goalPos)
            path_opt(end+1,:) = goalPos;
            break;
        else
            nodes = {treeNodes.node}';
            nodes = cell2mat(nodes);
            [~, idx] = ismember(x_nearest,nodes,'rows');
        end
    end
end

% 路径长度
path_diff = diff(path_opt);
len = sum(sqrt(path_diff(:,1).^2 + path_diff(:,2).^2));
nodeNum = size(path_opt, 1);
sampleNode = size(treeNodes2, 2) + ;
time = toc;

%% 画图
% plotFigureRrtConnect(map_size,startPos, goalPos, map, treeNodes1,treeNodes2,path_opt)
